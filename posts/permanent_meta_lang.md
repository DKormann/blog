
# permanent meta language

rambling a about the 'good language

i love language

i love programming

world is computer

someone: a field comes into its own when it finds its own language.

language seems for us to be a crystalization of (intuitive) knowledge

## global permanence

im fascinated by the ideas around of a global permanent immutable adress space.
[[1]](urbit.org)
[[2]](https://axsys.substack.com/p/towards-a-new-american-economics)

some version of this: every data piece lives globally at an adress thats just its hash.
it just seems to a lot of guarantees that feel just right and clean way to do things.
it pushes us into immutable data.

sometimes considered bad for performance machine learning can generally completely be implemented very well with immutable data. determinism is much harde:
Beyond purpusefull randomness GPUS are not expected to be fully deterministic (see: float accumulate).

## meta properties

live contains self modification and other meta processes
our language be able to talk about itself

### type

I love LEAN and recent work of [HOC](https://higherorderco.com)

A Type is like a program that talks about a program.
obviously this leads to higher order types.
we generally want types to terminate.

examples:
  * this is a number
  * this is list of numbers
  * this function sorts lists of numbers

strong types can encode any mathematical property


use cases:

 * verify ai generated code
 * different programms develped independently interact without errors. (by posting full types of their respective API)
 <!-- *  -->



### zk proof

A zk proof is a proof of function code + output without revealing inputs.
An efficient zk proof is fast to proof and very fast to verify. (verification doesnt scale with size of computation).
promising: [nockchain](https://www.nockchain.org/)


### native emulation



